#summary This is the script in use by my company to do all of our Altium output generation, packaging (zipping), and release-tag.  Everything is done within Subversion (SVN).

== Screen captures: ==

  * This is the main dialog box for the script.  (Note:  Some of the instructions listed are quite company specific and may not apply to you.)
https://altium-designer-addons.googlecode.com/svn/trunk/XIA_Release_Manager/docs/v1.8.10_screen_capture1.jpg
  * This is what the summary looks like after successfully completing generating outputs for all but fabrication, packaging assembly files, and doing release-and-tag for assembly.
https://altium-designer-addons.googlecode.com/svn/trunk/XIA_Release_Manager/docs/v1.8.10_screen_capture2.jpg

== WHAT THIS SCRIPT WILL DO: ==

  # This release manager script is intended to be an interface to a set of 6 OutJob files that were copied from company templates and somewhat customized for the project in question.  The 6 OutJob files exist to break up the task of output generation into 6 pieces, so that all output files need not be generated each time.  (This was XIA's previous setup, and wasted lots of time.)
  # This script will perform some of the same checks as the Altium builtin release manager:  checking for source files that are saved and checked in.
  # This script does a variety of additional sanity checks on the design, including checking version numbers between schematic and layout, checking for certain design elements required by company design rules, checking for existing releases of the current version number, etc.  It will also check that all output files that had been previously generated were, in fact, also generated this time around.
  # In the future, this script will likely also check that the schematic is in sync with the company components database, so that all schematic parameters (supplier part numbers, RoHS status, soldering info, etc.) are updated prior to generating a BOM.
  # Roughly speaking, this script is setup such that the user is allowed to run OutJobs 1; 1,2; 1,2,3; 1,2,3,4; 1,2,3,4,5; or 1,2,3,4,5,6.  In other words, running later OutJobs require the earlier ones.  So you can stop at a certain point, but you are not allowed to just run the later ones.  This limitation is by design, to make sure that the earlier OutJobs (which generate various outputs for design reviews, etc.) must be run prior to the later ones (which actually generate fab & assembly outputs).
  # This script will perform certain additional operations on certain output files, after Altium generates them.
  a. This script will sort a multi-wire netlist, so that a designer may use this sorted, human-readable, netlist to track connectivity changes as the design progresses.

  b. This script will (if necessary) fix Altium-generated IPC356 netlists in order to address an Altium bug that we've been hitting.

  c. This script will perform some additional handling in order to get an svn rev number inserted into Excel BOMs.

  d. This script will "mark" Excel BOMs when we're doing an assembly packaging operation.  This currently takes the form of replacing a special string within the xls file with a new string of the exact same length.  This operation is done with sed, outside of Excel.

  # This script will checkin all generated output files (including additional ones like sorted multiwire netlist and fixed IPC356 netlist) to svn, in trunk/.
  # If requested, this script will package (zip up) fabrication and/or assembly files and checkin those zipfiles to trunk/.
  a. If additional files (eg. additional documentation, etc.) in the fabrication and/or assembly include directories, these additional files will be added to the relevant zipfile(s).
  # If requested, this script will create new subdirs in releases/ and tags/, corresponding to the version and svn rev number of the current release(s).  It will then copy the zipfile(s) to the new subdir(s) in releases/.  Finally, it will make a project snapshot in the new subdir(s) in tags/.

==WHAT THIS SCRIPT WILL *NOT* DO:==
  # Generate and then gather up all the generated output files and then throw them over the wall into some other, unrelated document management system, as the Altium 10 builtin release manager does with their strange "Vault" concept.  We have a company svn server.  Everyone here has access to it.  Everyone knows how to use it.  Everyone has already been using it for Altium projects.  Why on earth would we want to throw releases over the wall into some unrelated document management system??  We want to use releases/ and tags/ in svn!!
  # Generate release output in some other sandbox directory, other than the project's usual ProjectOutputs/ directory.


==Function list:==
===Manage string lists to configure this script for your company's needs===
<code language="Delphi">
{{{
{***************************************************************************
 * function PopulateStringLists()
 *  Perform init step by populating several string lists.
 *  
 *  What we're doing here is telling the script some detailed information
 *  about each of our 6 OutJob files, as well as flagging some additional
 *  steps that need to be performed after running certain OutJob files.
 *
 *  Note:  Unusually for this script, this function will create all
 *  the var string lists.  They will need to be Free()'ed later.
 *
 *  Returns created and populated string lists in all of these var parms.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function PopulateStringLists(var projOutSubDirs             : TStringList;
                             var projOutIncludes            : TStringList;
                             var outJobFiles                : TStringList;
                             var outJobPdfContainers        : TStringList;
                             var outJobPdfEnableNets        : TStringList;
                             var outJobGenContainers        : TStringList;
                             var outJobStatusMsg            : TStringList;
                             var outJobDoSortMultiNetlist   : TStringList;
                             var outJobSetSvnKeywordsOnBoms : TStringList;
                             var outJobDoFixIpc356Netlist   : TStringList;
                             var deleteExcludes             : TStringList;
                             var zipDoCheckForExisting      : TStringList;
                             var zipExcludes                : TStringList;
                             var zipFindAddlFiles           : TStringList;
                             var zipFileNames               : TStringList;
                             var relAndTagSubDir            : TStringList;
                                 )                          : Integer;
}}}
</code>

===Misc string manipulation functions===
<code language="Delphi">
{{{
{***************************************************************************
 * function StripTrailingBackslash()
 *  Strip any trailing backslashes from a file path.
 *
 *  Returns stripped string as function return value.
 ***************************************************************************}
function StripTrailingBackslash(filePath : TDynamicString;
                                )        : TDynamicString;

{***************************************************************************
 * function SplitDelimitedStringIntoStringList()
 *  Splits a delimited string (eg. 'foo|bar|bin|bat|"gee whiz"') into a list containing
 *  eg. 'foo', 'bar', 'bin', 'bat', and 'gee whiz'.
 *  
 *  Note:  Assumes that stringList has already been created.
 *  Note:  Assumes that any field containing spaces (eg. "gee whiz" above) is quoted!
 *
 *  Returns populated string list in var parameter stringList.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function SplitDelimitedStringIntoStringList(    delimitedString : TDynamicString;
                                                delimiter       : TDynamicString;
                                            var stringList      : TStringList;
                                                )               : Integer;

{***************************************************************************
 * function SplitStringIntoLeftAndRight()
 *  Split a string with a single delimiter character into "left" and "right"
 *  halves.
 *  
 *  Returns left half in var parm leftStr.
 *  Returns right half in var parm rightStr.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function SplitStringIntoLeftAndRight(    splitMe   : TDynamicString;
                                         delimiter : TString;
                                     var leftStr   : TDynamicString;
                                     var rightStr  : TDynamicString;
                                         )         : Integer;

{***************************************************************************
 * function SplitStringIntoLeftAndRightWithAbort()
 *  Split a string with a single delimiter character into "left" and "right"
 *  halves.
 *  
 *  Returns left half in var parm leftStr.
 *  Returns right half in var parm rightStr.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function SplitStringIntoLeftAndRightWithAbort(    splitMe   : TDynamicString;
                                                  delimiter : TString;
                                              var leftStr   : TDynamicString;
                                              var rightStr  : TDynamicString;
                                                  )         : Integer;



}}}
</code>

===Misc file handling functions===
<code language="Delphi">
{{{
{***************************************************************************
 * function DeleteFileWithVerify()
 *  Try to delete a file and make sure we succeeded.
 *
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function DeleteFileWithVerify(filePath : TDynamicString;
                              )        : Integer;

{***************************************************************************
 * function MyFindFilesSpecifyRecursion()
 *  Search a given directory (either recursively or non-recursively)
 *  for files matching specified mask.
 *
 *  Note:  FilesOnly string list is assumed to have already been created by caller.
 *  
 *  Returns:  String list of generated files in var parameter FilesOnly.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function MyFindFilesSpecifyRecursion(    projOutPath : TString;
                                         subDir      : TString;
                                         mask        : TString;
                                         recursive   : Boolean;
                                     var FilesOnly   : TStringList);

{***************************************************************************
 * function MyFindFiles()
 *  Search a given directory for files matching specified mask.
 *  
 *  Note:  Assumes that list FilesOnly has already been created!
 *
 *  Returns:  String list of generated files in var parameter FilesOnly.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function MyFindFiles(    projOutPath : TString;
                         subDir      : TString;
                         mask        : TString;
                     var FilesOnly   : TStringList);

{***************************************************************************
 * function MyFindFilesRecursive()
 *  Search a given directory recursively for files matching specified mask.
 *  
 *  Note:  Assumes that list FilesOnly has already been created!
 *
 *  Returns:  String list of generated files in var parameter FilesOnly.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function MyFindFilesRecursive(    projOutPath : TString;
                                  subDir      : TString;
                                  mask        : TString;
                              var FilesOnly   : TStringList);

{***************************************************************************
 * function IsFileZeroLength()
 *  Determine if a given file is 0 length.
 *
 *  Returns:  True if file is 0 length, False if non-existent or non-zero length.
 ***************************************************************************}
function IsFileZeroLength(filePath : TDynamicString;
                          )        : Boolean;

{***************************************************************************
 * function IsFileWriteable()
 *  Determine if a given file is writeable (eg. not flocked by Excel or Acroread)..
 *
 *  Returns:  True if file is writeable, False if non-existent or non-writeable.
 ***************************************************************************}
function IsFileWriteable(filePath : TDynamicString;
                         )        : Boolean;

{***************************************************************************
 * function VerifyFileIsWriteable()
 *  Verify that a given file is writeable (eg. not flocked by Excel or Acroread).
 *  If it is flocked, warn the user to close it, then check one more time.
 *  If on the 2nd check the file is still flocked, then abort script with error.
 *
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function VerifyFileIsWriteable(filePath : TDynamicString;
                               )        : Boolean;

{***************************************************************************
 * function TruncateFile()
 *  Try to truncate a file to zero length.
 *
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function TruncateFile(filePath : TDynamicString;
                      )      : Integer;

{***************************************************************************
 * function TruncateFileWithVerify()
 *  Try to truncate a file to zero length and make sure we succeeded.
 *
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function TruncateFileWithVerify(filePath : TDynamicString;
                                )        : Integer;


{***************************************************************************
 * procedure OpenDebugFile()
 *  Open debug file for the first time.
 ***************************************************************************}
procedure OpenDebugFile(fileName :  TDynamicString);

{***************************************************************************
 * procedure WriteToDebugFile()
 *  Write a new line of text to the debug file.
 *  
 *  Note that we will be operating in append-write-close mode in order to
 *  prevent Altium from flocking this file in the event of an unhandled
 *  Altium script crash.
 ***************************************************************************}
procedure WriteToDebugFile(msg : TDynamicString);

{***************************************************************************
 * procedure CloseDebugFile()
 *  Close debug file.
 *
 *  Note:  Since we're now operating in append-write-close mode, there's
 *  no longer anything we actually have to do here.
 *  
 *  Note:  foo is a dummy parameter that exists only to keep CloseDebugFile()
 *  from being offered as the script entry point in Altium.
 ***************************************************************************}
procedure CloseDebugFile(foo : Integer);

{***************************************************************************
 * procedure OpenSummaryFile()
 *  Open summary file for the first time.
 ***************************************************************************}
procedure OpenSummaryFile(fileName :  TDynamicString);

{***************************************************************************
 * procedure WriteToSummaryFile()
 *  Write a new line of text to the summary file.
 *  
 *  Note that we will be operating in append-write-close mode in order to
 *  prevent Altium from flocking this file in the event of an unhandled
 *  Altium script crash.
 ***************************************************************************}
procedure WriteToSummaryFile(msg : TDynamicString);

{***************************************************************************
 * procedure CloseSummaryFile()
 *  Close summary file.
 *
 *  Note:  Since we're now operating in append-write-close mode, there's
 *  very little that we actually have to do here.
 *  
 *  Note:  foo is a dummy parameter that exists only to keep CloseDebugFile()
 *  from being offered as the script entry point in Altium.
 ***************************************************************************}
procedure CloseSummaryFile(foo : Integer);

}}}
</code>

===Misc user interface functions===
<code language="Delphi">
{{{
{***************************************************************************
 * procedure UpdateGuiStatusMessage()
 *  Update status message in dialog box and write said status to the debug file.
 ***************************************************************************}
procedure UpdateGuiStatusMessage(msg :  TDynamicString);

{***************************************************************************
 * procedure IssueDialogBoxWithOkOrCancel()
 *  Present the user with a dialog box of the specified type, with a specified message in it.
 *  If user clicks OK, optionally display "ok" message and return to caller.
 *  If user clicks Cancel, then abort script with "cancel" message.
 ***************************************************************************}
procedure IssueDialogBoxWithOkOrCancel(dialogType : TMsgDlgType;
                                       msg        : TDynamicString;
                                       okMsg      : TDynamicString;
                                       cancelMsg  : TDynamicString);

{***************************************************************************
 * procedure IssueConfirmationWithOkOrCancel()
 *  Present the user with a confirmation dialog box with a specified message in it.
 *  If user clicks OK, optionally display "ok" message and return to caller.
 *  If user clicks Cancel, then abort script with "cancel" message.
 ***************************************************************************}
procedure IssueConfirmationWithOkOrCancel(msg       : TDynamicString;
                                          okMsg     : TDynamicString;
                                          cancelMsg : TDynamicString);

{***************************************************************************
 * procedure IssueWarningWithOkOrCancel()
 *  Present the user with a warning dialog box with a specified message in it.
 *  If user clicks OK, optionally display "ok" message and return to caller.
 *  If user clicks Cancel, then abort script with "cancel" message.
 ***************************************************************************}
procedure IssueWarningWithOkOrCancel(msg       : TDynamicString;
                                     okMsg     : TDynamicString;
                                     cancelMsg : TDynamicString);

}}}
</code>

===Functions to handle calling external scripts===
<code language="Delphi">
{{{
{***************************************************************************
 * function CleanupSvnRcFile()
 *  Try to delete rc file from external svn command.
 *
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function CleanupSvnRcFile(svnRcPath : TDynamicString;
                          )         : Integer;


{***************************************************************************
 * function AwaitSvnCompletion()
 *  Wait for the external svn command to complete.
 *
 *  Returns first line in svn return code file in var parm svnRc.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function AwaitSvnCompletion(    svnRcPath    : TDynamicString;
                                timeoutLimit : Integer;
                            var svnRc        : TDynamicString;
                                )            : Integer;

{***************************************************************************
 * function IssueSvnCommandGetOutput()
 *  Shell out and call bat file to issue a generic svn command.
 *  Check its return code, and return all output generated by svn.exe.
 *
 *  Returns all svn output in var parm svnOut.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function IssueSvnCommandGetOutput(    scriptsPath : TDynamicString;
                                      projectPath : TDynamicString;
                                      command     : TDynamicString;
                                      parms       : TStringList;
                                  var svnOut      : TStringList;
                                      )           : Integer;

{***************************************************************************
 * function IssueSvnCommandLookForOutputLine()
 *  Shell out and call bat file to issue a generic svn command.
 *  Check its return code, and look for a specific line in its output.
 *
 *  Returns the line of svn output containing "lookForMe" as var parm foundInLine.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function IssueSvnCommandLookForOutputLine(    scriptsPath : TDynamicString;
                                              projectPath : TDynamicString;
                                              command     : TDynamicString;
                                              parms       : TStringList;
                                              lookForMe   : TDynamicString;
                                          var foundInLine : TDynamicString;
                                              )           : Integer;

{***************************************************************************
 * function IssueSvnCommand()
 *  Shell out and call bat file to issue a generic svn command.
 *  Check its return code, but ignore its output.
 *
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function IssueSvnCommand(scriptsPath : TDynamicString;
                         projectPath : TDynamicString;
                         command     : TDynamicString;
                         parms       : TStringList;
                         )           : Integer;

{***************************************************************************
 * function DoSvnRevert()
 *  Do a recursive svn revert on 1 or 2 specified directories.
 *
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function DoSvnRevert(scriptsPath : TDynamicString;
                     projectPath : TString;
                     dir1        : TDynamicString;
                     dir2        : TDynamicString;
                     )           : Integer;

{***************************************************************************
 * function DoSvnInfoAndGetOneLine()
 *  Query via svn info and look for a line of text starting with "findLine".
 *
 *  Returns line we found in svn reply, not counting the header we were looking for.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function DoSvnInfoAndGetOneLine(    scriptsPath : TDynamicString;
                                    projectPath : TString;
                                    fileOrDir   : TString;
                                    findLine    : TString;
                                var foundLine   : TDynamicString;
                                    )           : Integer;

{***************************************************************************
 * function GetFileOrDirSvnServerUrl()
 *  Query to get the svn server side URL for a specified file or directory.
 *
 *  Returns svn server side URL in var parm fileOrDirUrl.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function GetFileOrDirSvnServerUrl(    scriptsPath : TDynamicString;
                                      projectPath  : TString;
                                      fileOrDir    : TString;
                                  var fileOrDirUrl : TDynamicString;
                                      )            : Integer;

{***************************************************************************
 * function GetFileSvnRevNum()
 *  Query to get the latest svn rev number for a specified file.
 *
 *  Returns svn rev number (in string form) in var parm fileRevNum.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function GetFileSvnRevNum(    scriptsPath : TDynamicString;
                              projectPath  : TDynamicString;
                              filePath     : TDynamicString;
                          var fileRevNum   : TDynamicString;
                              )            : Integer;

{***************************************************************************
 * function RunSomeSedBatFile()
 *  Shell out and call specified batFile to run some sed-related command.
 *  Check its return code.
 *
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function RunSomeSedBatFile(scriptsPath : TDynamicString;
                           projectPath : TDynamicString;
                           inputPath   : TDynamicString;
                           outputPath  : TDynamicString;
                           batFile     : TDynamicString;
                           command     : TDynamicString;
                           )           : Integer;

{***************************************************************************
 * function RunSed()
 *  Shell out and call bat file to run standard sed command.
 *  Check its return code.
 *
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function RunSed(scriptsPath : TDynamicString;
                projectPath  : TDynamicString;
                inputPath    : TDynamicString;
                outputPath   : TDynamicString;
                command      : TDynamicString;
                )            : Integer;

{***************************************************************************
 * function RunPatchWithSed()
 *  Shell out and call bat file to run patch sed command.
 *  Check its return code.
 *
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function RunPatchWithSed(scriptsPath : TDynamicString;
                         projectPath : TDynamicString;
                         inputPath   : TDynamicString;
                         outputPath  : TDynamicString;
                         command     : TDynamicString;
                         )           : Integer;

{***************************************************************************
 * function RunSortMulti()
 *  Shell out and call bat file to sort Multiwire netlist.
 *  Check its return code.
 *
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function RunSortMulti(scriptsPath : TDynamicString;
                      projectPath  : TDynamicString;
                      inputPath    : TDynamicString;
                      outputPath   : TDynamicString;
                      )            : Integer;


}}}
</code>

===Mid-level script functions (mostly file related)===
<code language="Delphi">
{{{
{***************************************************************************
 * function CreateSubDir()
 *  Ensures that a given subdirectory exists.  If not, create it.
 *  Return a list of directories created.
 *
 *  Note:  Previously this code would also attempt to restore a locally
 *  deleted directory by running svn update.  However, we now handle that
 *  operation by doing an svn revert of the directory tree long before we get here.
 *
 *  Note:  Assumes that string list newSubDirs has already been created.
 *
 *  Adds current subDir to var parm subDirs.
 *  If new subDir is created, it is added to var parm newSubDirs
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function CreateSubDir(    scriptsPath : TDynamicString;
                          projectPath : TDynamicString;
                          subDir      : TString;
                      var newSubDirs  : TStringList;
                          )           : Integer;

{***************************************************************************
 * function CreateOutputSubDir()
 *  Ensures that a given output subdirectory exists.  If not, create it.
 *
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function CreateOutputSubDir(scriptsPath : TDynamicString;
                            projectPath : TDynamicString;
                            projOutPath : TString;
                            subDir      : TString;
                            )           : Integer;

{***************************************************************************
 * function CreateAllOutputSubDirs()
 *  Ensures that all output subdirectories exist.  If any do not, create them.
 *
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function CreateAllOutputSubDirs(scriptsPath     : TDynamicString;
                                projectPath     : TDynamicString;
                                projOutPath     : TString;
                                projOutSubDirs  : TStringList;
                                projOutIncludes : TStringList;
                                )               : Integer;

{***************************************************************************
 * function ExcludeFilesFromList()
 *  Process a list of files.  For each file, see if the filename or the fileext
 *  matches a list of excludes.  If so, remove it from the list.
 *
 *  Note:  Assumes that fileList stringlist has already been created.
 *
 *  Returns modified string list as var parm fileList.
 *  Returns:  0 on success, 1 if unable to delete one or more files
 ***************************************************************************}
function ExcludeFilesFromList(var fileList : TStringList;
                                  excludes : TStringList;
                                  )        : Integer;

{***************************************************************************
 * function DeleteOutputFiles()
 *  Attempt to delete all files in a specified subdirectory of ProjectOutputs.
 *  Take a list of files to exclude from deletion.
 *
 *  Returns:  0 on success, 1 if unable to delete one or more files
 ***************************************************************************}
function DeleteOutputFiles(projOutPath : TString;
                           subDir      : TString;
                           excludes    : TStringList;
                           )           : Integer;

{***************************************************************************
 * function DeleteAllOutputFiles()
 *  Attempt to delete all files in all output subdirs of ProjectOutputs.
 *  Take a list of output subdirs and a list of files to exclude from
 *  deletion for each subdir.
 *
 *  Returns:  0 on success, 1 if unsuccessful.
 ***************************************************************************}
function DeleteAllOutputFiles(projOutPath    : TString;
                              projOutSubDirs : TStringList;
                              deleteExcludes : TStringList;
                              runOutJobs     : TStringList;
                              )              : Integer;

{***************************************************************************
 * function CheckThatSvnScriptsWorkingCopyIsUpdated()
 *  Make sure that the working copy containing our scripts and libraries
 *  is up-to-date with respect to the svn server.
 *
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function CheckThatSvnScriptsWorkingCopyIsUpdated(scriptsPath : TDynamicString;
                                                 )           : Integer;

{***************************************************************************
 * function CheckForUnCheckedInFiles()
 *  Do an svn status command in project home to look for files
 *  that have not been checked into svn.
 *
 *  Returns:  0 on success, 1 if unsuccessful.
 ***************************************************************************}
function CheckForUnCheckedInFiles(scriptsPath : TDynamicString;
                                  projectPath : TString;
                                  filePaths   : TStringList;
                                  msg         : TDynamicString;
                                  )           : Integer;

{***************************************************************************
 * function CheckForUnCheckedInSourceFiles()
 *  Do an svn status command in project home to look for source files
 *  that have not been checked into svn.
 *
 *  Returns:  0 on success, 1 if unsuccessful.
 ***************************************************************************}
function CheckForUnCheckedInSourceFiles(scriptsPath     : TDynamicString;
                                        projectPath     : TString;
                                        sourceFilePaths : TStringList;
                                        )               : Integer;

{***************************************************************************
 * function CheckForAllMissingOutputFiles()
 *  Do an svn status command in ProjectOutputs SubDirs to look for files
 *  that exist in svn repo but do not exist in working copy.
 *
 *  This situation occurs when an output file was previously generated and
 *  checked into svn, but then the user disabled that output in OutJob
 *  files before running this script.
 *
 *  Of course, it can also occur when a legitimate change (reducing number
 *  of PcbDoc layers, reducing number of variants, etc.) results in fewer
 *  output files being generated compared to last time this script was run.
 *  In this event, the user must manually svn delete the file(s) in question
 *  and re-run this release manager script.
 *
 *  Returns:  0 on success, 1 if unsuccessful.
 ***************************************************************************}
function CheckForAllMissingOutputFiles(scriptsPath    : TDynamicString;
                                       projOutPath    : TString;
                                       projOutSubDirs : TStringList;
                                       )              : Integer;

{***************************************************************************
 * function CheckForUnsavedSource()
 *  Iterate over all the source documents in the project.
 *  Make sure that they've all been saved to disk.
 *
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function CheckForUnsavedSource(sourceFilePaths : TStringList;
                               )               : Integer;

}}}
</code>

===Mid-level functions to analyze project===
<code language="Delphi">
{{{
{***************************************************************************
 * function GetSourceFilesAndFindTopLevelSchDoc()
 *  Iterate over all the source documents in the project.
 *  Return a list of the paths to all source documents.
 *
 *  While we're at it, also identify the top level schematic document.
 *  This will be used later to find the pcb version number.
 *
 *  Also while we're at it, identify the project file name.
 *  This will be used later to increment the pcba version number.
 *
 *  Returns source files in var parm sourceFilePaths.
 *  Returns top level schematic as var parm topLevelSchDoc.
 *  Returns project file name as var parm projFilePath.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function GetSourceFilesAndFindTopLevelSchDoc(    Project         : IProject;
                                             var sourceFilePaths : TStringList;
                                             var topLevelSchDoc  : IDocument;
                                             var projFilePath    : TDynamicString;
                                                 )               : Integer;

{***************************************************************************
 * function GetPcbAndPcbaVersions()
 *  Get the PCB (pcb fabrication) project properties.
 *  Get the PCBA (pcb assembly) project properties.
 *
 *  If the user wishes to package fabrication, then require presence of PCB parms.
 *  If the user wishes to package assembly, then require presence of PCB parms.
 *
 *  Returns modified project parms list as var parm projectParms.
 *  Returns PCB part number and version as string in var parm pcbPartNumAndVersion.
 *  Returns PCBA version as string in var parm pcbaVersion.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function GetPcbAndPcbaVersions(    Project              : IProject;
                                   projOutSubDirs       : TStringList;
                                   runPackager          : TStringList;
                               var projectParms         : TStringList;
                               var pcbPartNumAndVersion : TDynamicString; 
                               var pcbaVersion          : TDynamicString; 
                                   )                    : Integer;

{***************************************************************************
 * function SplitPcbPartNumAndVersion()
 *  Split a string that contains both the PCB part number (eg. "MICROCAL-MAIN")
 *  and the PCB version number (eg. "1.13") into its component parts.
 *
 *  Returns PCB part number in var parm pcbPartNum.
 *  Returns PCB version number in var parm pcbVersion.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function SplitPcbPartNumAndVersion(    pcbPartNumAndVersion : TDynamicString;
                                   var pcbPartNum           : TDynamicString;
                                   var pcbVersion           : TDynamicString; 
                                   )                        : Integer;

{***************************************************************************
 * function GetPcbVersionNumbersFromTopLevelSchDoc()
 *  
 *  In top level schematic document, find the schematic component with refdes "APCB1".
 *  Also find the Gerber Title Block component that will have some refdes "XX*".
 *  
 *  APCB1 will have a MFGNUMBER parameter that looks something like
 *  "PCB-MICROCAL_MAIN-1.13 Build Rev 19894".
 *  Return everything up to the last char before the first space (eg. "PCB-MICROCAL_MAIN-1.13") as var parm schApcb1MnoPcbPartNum.
 *  Return everyting after the last space char (eg. "19894") as var parm schApcb1MnoPcbRevNum.
 *
 *  APCB1 will have a VALUE parameter that looks something like
 *  "PCB-MICROCAL_MAIN-1.13".
 *  Return this as var parm schApcb1ValPcbPartNum.
 *
 *  APCB1 will have a Comment parameter that looks something like
 *  "PCB-MICROCAL_MAIN-1.13" or "=VALUE".
 *  Return this as var parm schApcb1ComPcbPartNum.
 *
 *  GerberTitleBlock component (XX something) with have a Comment parameter that looks something like
 *  "PCB-MICROCAL_MAIN-1.13".
 *  Return this as var parm schGtbPcbPartNum.
 *
 *  NOTE:  This entire function is highly specific to the required design
 *  elements at XIA LLC.  It would need to be generalized or modified to
 *  support another company's requirements!
 *  
 *  Returns : 0 on success, 1 if not successful.
 ***************************************************************************}
function GetPcbVersionNumbersFromTopLevelSchDoc(    topLevelSchDoc                  : IDocument,
                                                var schApcb1MnoPcbPartNumAndVersion : TDynamicString;   { PCB part number and version as reported by SCH component APCB1, MFGNUMBER field. }
                                                var schApcb1ValPcbPartNumAndVersion : TDynamicString;   { PCB part number and version as reported by SCH component APCB1, VALUE field. }
                                                var schApcb1ComPcbPartNumAndVersion : TDynamicString;   { PCB part number and version as reported by SCH component APCB1, Comment field. }
                                                var schApcb1MnoPcbRevNum            : TDynamicString;   { PcbDoc file svn rev number as reported by SCH component APCB1, MFGNUMBER field. }
                                                var schGtbPcbPartNumAndVersion      : TDynamicString;   { PCB part number and version as reported by SCH component gerber title block, Comment field. }
                                                var gtbRefDes                       : TDynamicString;
                                               )                                    : Integer;

{***************************************************************************
 * function FindProjectPcbDocFile()
 *  Find the PcbDoc file associated with this project.
 *  Panic if we find any number not equal to 1 (eg 0 or 2).
 *  
 *  Returns full path to this project's PcbDoc file in var parm pcbDocPath.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function FindProjectPcbDocFile(    Project               : IProject;
                                   flagRequirePcbDocFile : Boolean;
                               var pcbDocPath            : TDynamicString; 
                               )                         : Integer;

{***************************************************************************
 * function GetPcbVersionNumbersFromPcbDoc()
 *  
 *  Find the PCB component with refdes "APCB1".
 *  
 *  APCB1 will have a Comment parameter that looks something like
 *  "PCB-MICROCAL_MAIN-1.13" or "=VALUE".
 *  Return this as var parm pcbApcb1PcbPartNumAndVersion.
 *
 *  GerberTitleBlock component (XX something) with have a Comment parameter that looks something like
 *  "PCB-MICROCAL_MAIN-1.13".
 *  Return this as var parm pcbGtbPcbPartNumAndVersion.
 *
 *  NOTE:  This entire function is highly specific to the required design
 *  elements at XIA LLC.  It would need to be generalized or modified to
 *  support another company's requirements!
 *  
 *  Returns : 0 on success, 1 if not successful.
 ***************************************************************************}
function GetPcbVersionNumbersFromPcbDoc(    pcbDocPath                   : TDynamicString;
                                            gtbRefDes                    : TDynamicString;
                                        var pcbApcb1PcbPartNumAndVersion : TDynamicString;  { PCB part number and version as reported by PCB component APCB1. }
                                        var pcbGtbPcbPartNumAndVersion   : TDynamicString;  { PCB part number and version as reported by PCB component gerber title block. }
                                        var step                         : Integer;
                                            )                            : Integer;

{***************************************************************************
 * function GetPcbDocFileSvnRevNum()
 *  Get the latest svn rev number for the PcbDoc file.
 *
 *  Returns svn rev number (in string form) in var parm pcbDocRevNum.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function GetPcbDocFileSvnRevNum(    scriptsPath  : TDynamicString;
                                    projectPath  : TDynamicString;
                                    pcbDocPath   : TDynamicString;
                                var pcbDocRevNum : TDynamicString;
                                var step         : Integer;
                                    )            : Integer;


{***************************************************************************
 * function GetPcbAndPcbaPartNumsVersionsAndRevs()
 *  Get pcbPartNum and pcbVersion information from several sources:
 *  (a) Project level properties
 *  (b) Top Level schematic document
 *  (c) PcbDoc file
 *  and make sure that these all agree.
 *
 *  Get pcbaPartNum and pcbaVersion information from project level properties.
 *
 *  NOTE:  This entire function is highly specific to the required design
 *  elements at XIA LLC.  It would need to be generalized or modified to
 *  support another company's requirements!
 *  
 *  TODO:  Handle future use case where we are doing only release and tag,
 *  and not packaging files this time around. (??)
 *
 *  Returns list of all project level paramters as var parm projectParms.
 *  Returns pcb part number as var parm pcbPartNum.
 *  Returns pcb version number as var parm pcbVersion.
 *  Returns svn rev number of PcbDoc file as var parm pcbDocRevNum.
 *  Returns pcba part number as var parm pcbaPartNum.
 *  Returns pcba version number of project as var parm pcbaVersion.
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function GetPcbAndPcbaPartNumsVersionsAndRevs(    Project               : IProject;
                                                  projectName           : TDynamicString;
                                                  scriptsPath           : TDynamicString;
                                                  projectPath           : TDynamicString;
                                                  projOutPath           : TDynamicString;
                                                  projOutSubDirs        : TStringList;
                                                  zipFileNames          : TStringList;
                                                  flagRequirePcbDocFile : Boolean;
                                                  runPackager           : TStringList;
                                                  topLevelSchDoc        : IDocument;
                                              var projectParms          : TStringList;
                                              var pcbPartNum            : TDynamicString;
                                              var pcbVersion            : TDynamicString;
                                              var pcbDocRevNum          : TDynamicString;
                                              var pcbaPartNum           : TDynamicString;
                                              var pcbaVersion           : TDynamicString;
                                              var step                  : Integer;
                                                  )                     : Integer;

{***************************************************************************
 * function SanityCheckRelAndTag()
 *  Perform sanity checks before starting release & tag operation.
 *
 *  Returns:  0 on success, 1 if not successful.
 ***************************************************************************}
function SanityCheckRelAndTag(scriptsPath : TDynamicString;
                              projectPath : TDynamicString;
                              )           : Integer;

}}}
</code>